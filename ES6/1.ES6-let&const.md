# let命令
1. 基本用法
> for循环还有一个特别之处，就是循环语句部分是一个父作用域，而循环体内部是一个单独的子作用域。
2. 不存在变量提升
> let命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错。
3. 暂时性死区
> 在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。

> 暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。
4. 不允许重复声明
> let不允许在相同作用域内，重复声明同一个变量。

# 块级作用域
1. 为什么需要块级作用域
> ES5只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。

> 第一种场景，内层变量可能会覆盖外层变量。

> 第二种场景，用来计数的循环变量泄露为全局变量。
2. ES6的块级作用域
> ES6允许块级作用域的任意嵌套。

> 内层作用域可以定义外层作用域的同名变量。

> 外层作用域无法读取内层作用域的变量。

> 块级作用域的出现，实际上使得获得广泛应用的立即执行函数表达式（IIFE）不再必要了。
3. 块级作用域与函数声明
> ES6 引入了块级作用域，明确允许在块级作用域之中声明函数。

> 考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。

> ES6 的块级作用域允许声明函数的规则，只在使用大括号的情况下成立，如果没有使用大括号，就会报错。
4. do表达式
> 现在有一个提案，使得块级作用域可以变为表达式，也就是说可以返回值，办法就是在块级作用域之前加上do，使它变为do表达式。

# const命令
> 对于const来说，只声明不赋值，就会报错。

> const声明的常量，也与let一样不可重复声明。

> 对于复合类型的变量，变量名不指向数据，而是指向数据所在的地址。const命令只是保证变量名指向的地址不变，并不保证该地址的数据不变，所以将一个对象声明为常量必须非常小心。

> 如果真的想将对象冻结，应该使用Object.freeze方法。

# 顶层对象的属性
> 顶层对象的属性与全局变量挂钩，被认为是JavaScript语言最大的设计败笔之一。

> ES6为了改变这一点，一方面规定，为了保持兼容性，var命令和function命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。

# global对象
> 现在有一个提案，在语言标准的层面，引入global作为顶层对象。也就是说，在所有环境下，global都是存在的，都可以从它拿到顶层对象。
